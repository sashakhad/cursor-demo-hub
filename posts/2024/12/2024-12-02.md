---
title: "Building Scalable React Components"
date: "2024.12.02"
tags: [react, components, architecture, frontend]
---

Creating maintainable and scalable React components is crucial for long-term project success. Here are the patterns and practices I've learned from building production applications.

## Component Design Principles

### 1. Single Responsibility Principle
Each component should have one clear purpose:

```jsx
// ❌ Bad: Component doing too many things
function UserProfileCard({ user, onEdit, onDelete, showAnalytics }) {
  // Handles display, editing, deletion, and analytics
}

// ✅ Good: Focused components
function UserProfile({ user }) {
  return (
    <div>
      <UserAvatar user={user} />
      <UserInfo user={user} />
      <UserActions user={user} />
    </div>
  );
}
```

### 2. Composition Over Inheritance
Use composition to build flexible components:

```jsx
// ✅ Flexible card component
function Card({ children, variant = "default" }) {
  return (
    <div className={`card card--${variant}`}>
      {children}
    </div>
  );
}

// Usage
<Card variant="highlighted">
  <CardHeader title="User Profile" />
  <CardBody>
    <UserInfo user={user} />
  </CardBody>
</Card>
```

## State Management Patterns

### Local State First
Start with local state and lift up only when necessary:

```jsx
function SearchInput({ onSearch }) {
  const [query, setQuery] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    await onSearch(query);
    setIsLoading(false);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        disabled={isLoading}
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? "Searching..." : "Search"}
      </button>
    </form>
  );
}
```

### Custom Hooks for Logic Reuse
Extract complex logic into custom hooks:

```jsx
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);
  
  return { data, loading, error };
}

// Usage in component
function UserList() {
  const { data: users, loading, error } = useApi('/api/users');
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      {users.map(user => <UserCard key={user.id} user={user} />)}
    </div>
  );
}
```

## Performance Optimization

### Memoization Strategies
Use React.memo and useMemo strategically:

```jsx
// Memoize expensive calculations
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      computed: expensiveCalculation(item)
    }));
  }, [data]);
  
  return <div>{/* render processedData */}</div>;
});

// Memoize callback functions
function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("");
  
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);
  
  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <ExpensiveChild onClick={handleClick} />
    </div>
  );
}
```

## Testing Strategies

### Component Testing
Focus on behavior, not implementation:

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import SearchInput from './SearchInput';

test('calls onSearch when form is submitted', async () => {
  const mockOnSearch = jest.fn();
  render(<SearchInput onSearch={mockOnSearch} />);
  
  const input = screen.getByRole('textbox');
  const button = screen.getByRole('button', { name: /search/i });
  
  fireEvent.change(input, { target: { value: 'react' } });
  fireEvent.click(button);
  
  expect(mockOnSearch).toHaveBeenCalledWith('react');
});
```

## Key Takeaways

1. **Keep components focused** - One responsibility per component
2. **Favor composition** - Build flexible, reusable pieces
3. **Start simple** - Add complexity only when needed
4. **Test behavior** - Focus on what users experience
5. **Optimize wisely** - Profile before optimizing

Building scalable React components is about finding the right balance between flexibility and simplicity. Start with clear, focused components and evolve them as your application grows.
