---
title: "Getting Started with Docker"
date: "2025.04.05"
tags: [docker, containers, devops, deployment]
---

Docker has become an essential tool for modern software development. It enables developers to package applications with all their dependencies, ensuring consistent behavior across different environments.

## What is Docker?

Docker is a platform for developing, shipping, and running applications using containerization. Containers package your application and its dependencies into a single, portable unit.

### Benefits
- **Consistency**: Works the same on development, staging, and production
- **Isolation**: Applications don't interfere with each other
- **Portability**: Run anywhere Docker is installed
- **Scalability**: Easy to scale horizontally

## Core Concepts

### Images
Images are read-only templates used to create containers. They define what your application needs to run.

### Containers
Containers are running instances of images. You can create multiple containers from the same image.

### Dockerfile
A Dockerfile is a text file containing instructions for building an image.

## Basic Dockerfile

```dockerfile
# Use an official base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Run the application
CMD ["node", "server.js"]
```

## Building and Running

```bash
# Build an image
docker build -t my-app .

# Run a container
docker run -p 3000:3000 my-app

# Run in detached mode
docker run -d -p 3000:3000 my-app

# View running containers
docker ps

# View logs
docker logs <container-id>

# Stop a container
docker stop <container-id>
```

## Docker Compose

Docker Compose allows you to define and run multi-container applications.

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

Run with:
```bash
docker-compose up -d
```

## Multi-Stage Builds

Optimize image size with multi-stage builds:

```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY --from=builder /app/dist ./dist
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

## Volumes

Persist data across container restarts:

```bash
# Create a volume
docker volume create my-data

# Mount a volume
docker run -v my-data:/data my-app

# Bind mount (for development)
docker run -v $(pwd):/app my-app
```

## Networking

Connect containers:

```bash
# Create a network
docker network create my-network

# Run containers on the network
docker run --network my-network my-app
docker run --network my-network postgres
```

## Best Practices

1. **Use specific tags** - Avoid `latest` in production
2. **Minimize layers** - Combine RUN commands
3. **Use .dockerignore** - Exclude unnecessary files
4. **Run as non-root** - For security
5. **Keep images small** - Use Alpine or distroless images
6. **One process per container** - Follow single responsibility
7. **Use health checks** - Monitor container health

## Useful Commands

```bash
# Remove stopped containers
docker container prune

# Remove unused images
docker image prune

# View resource usage
docker stats

# Execute command in running container
docker exec -it <container-id> sh

# Copy files to/from container
docker cp <container-id>:/path/to/file ./
```

Docker simplifies deployment and ensures your applications run consistently across all environments.

