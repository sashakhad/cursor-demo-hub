---
title: "Introduction to GraphQL"
date: "2025.04.18"
tags: [graphql, api, backend, web-development]
---

GraphQL is a query language and runtime for APIs that provides a more efficient, powerful, and flexible alternative to REST. It allows clients to request exactly the data they need, nothing more.

## What is GraphQL?

GraphQL is a specification created by Facebook that describes a query language and a set of conventions for building APIs. Unlike REST, which has multiple endpoints for different resources, GraphQL exposes a single endpoint.

### Key Advantages
- **Precise Data Fetching**: Request only the fields you need
- **Single Request**: Get multiple resources in one query
- **Strongly Typed**: Clear contract between client and server
- **Introspection**: Self-documenting API schema
- **Versioning**: Evolve API without versioning

## Basic Concepts

### Schema Definition

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  publishedAt: DateTime!
}

type Query {
  user(id: ID!): User
  users: [User!]!
  post(id: ID!): Post
  posts: [Post!]!
}

type Mutation {
  createUser(name: String!, email: String!): User!
  createPost(title: String!, content: String!): Post!
}
```

### Querying Data

```graphql
query {
  user(id: "1") {
    name
    email
    posts {
      title
      publishedAt
    }
  }
}
```

### Mutations

```graphql
mutation {
  createUser(name: "John Doe", email: "john@example.com") {
    id
    name
    email
  }
}
```

## Resolvers

Resolvers are functions that handle fetching data for each field:

```typescript
const resolvers = {
  Query: {
    user: async (parent, args, context) => {
      return await db.user.findUnique({ where: { id: args.id } });
    },
    users: async () => {
      return await db.user.findMany();
    }
  },
  User: {
    posts: async (parent) => {
      return await db.post.findMany({ where: { authorId: parent.id } });
    }
  },
  Mutation: {
    createUser: async (parent, args) => {
      return await db.user.create({ data: args });
    }
  }
};
```

## Variables

Make queries dynamic with variables:

```graphql
query GetUser($userId: ID!) {
  user(id: $userId) {
    name
    email
  }
}
```

Pass variables:
```json
{
  "userId": "123"
}
```

## Fragments

Reuse field selections:

```graphql
fragment UserInfo on User {
  id
  name
  email
}

query {
  user(id: "1") {
    ...UserInfo
    posts {
      title
    }
  }
}
```

## Directives

Control query execution:

```graphql
query {
  user(id: "1") {
    name
    email @include(if: $includeEmail)
    posts @skip(if: $skipPosts) {
      title
    }
  }
}
```

## Subscriptions

Real-time updates with subscriptions:

```graphql
type Subscription {
  postCreated: Post!
  userUpdated: User!
}
```

```typescript
const resolvers = {
  Subscription: {
    postCreated: {
      subscribe: () => pubsub.asyncIterator(['POST_CREATED'])
    }
  }
};
```

## Error Handling

```graphql
type User {
  id: ID!
  name: String!
  email: String!
}

type Mutation {
  createUser(name: String!, email: String!): UserResult!
}

union UserResult = User | ValidationError

type ValidationError {
  message: String!
  field: String!
}
```

## Best Practices

1. **Use descriptive names** - Clear, self-documenting names
2. **Implement pagination** - For list fields
3. **Use enums** - For fixed sets of values
4. **Handle errors gracefully** - Return proper error types
5. **Use DataLoader** - Batch and cache requests
6. **Implement rate limiting** - Protect your API
7. **Document your schema** - Add descriptions to fields

## Common Patterns

### Pagination

```graphql
type Query {
  posts(first: Int, after: String): PostConnection!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}
```

### Filtering

```graphql
type Query {
  posts(filter: PostFilter): [Post!]!
}

input PostFilter {
  authorId: ID
  publishedAfter: DateTime
  tags: [String!]
}
```

GraphQL offers a modern approach to API design that improves developer experience and application performance. Start exploring it in your next project!

