---
title: "Understanding React Server Components"
date: "2025.03.10"
tags: [react, server-components, nextjs, web-development]
---

React Server Components are revolutionizing how we build React applications. They enable us to create components that run exclusively on the server, reducing client-side JavaScript and improving performance.

## What Are Server Components?

Server Components are React components that render on the server and return serialized JavaScript to the client. Unlike traditional Server-Side Rendering (SSR), Server Components don't hydrate on the client.

Key benefits:
- Zero JavaScript sent to the client
- Direct access to backend resources
- Automatic code splitting
- Streaming rendering

## Server vs Client Components

Server Components run only on the server and can't use hooks or browser APIs:

```typescript
// ✅ Server Component
async function ServerComponent() {
  const data = await fetch('https://api.example.com/data');
  const json = await data.json();
  
  return <div>{json.title}</div>;
}

// ❌ Won't work - using a hook
function ServerComponent() {
  const [state, setState] = useState(); // Error!
  return <div>...</div>;
}
```

Client Components run on both server and client:

```typescript
'use client';

function ClientComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

## Composition Pattern

You can compose Server and Client Components together:

```typescript
// Server Component
async function ProductPage({ id }: { id: string }) {
  const product = await fetchProduct(id);
  
  return (
    <div>
      <h1>{product.name}</h1>
      <ProductImage url={product.imageUrl} />
      <AddToCartButton productId={id} />
    </div>
  );
}

// Server Component - fetches data
async function ProductImage({ url }: { url: string }) {
  const imageData = await fetchImageData(url);
  return <img src={imageData.src} alt={imageData.alt} />;
}

// Client Component - needs interactivity
'use client';
function AddToCartButton({ productId }: { productId: string }) {
  const [adding, setAdding] = useState(false);
  
  const handleClick = async () => {
    setAdding(true);
    await addToCart(productId);
    setAdding(false);
  };
  
  return (
    <button onClick={handleClick} disabled={adding}>
      {adding ? 'Adding...' : 'Add to Cart'}
    </button>
  );
}
```

## Data Fetching

Server Components simplify data fetching:

```typescript
async function BlogPost({ slug }: { slug: string }) {
  const post = await fetchPost(slug);
  const comments = await fetchComments(slug);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
      <CommentsList comments={comments} />
    </article>
  );
}
```

## Streaming and Suspense

Server Components support streaming with Suspense:

```typescript
import { Suspense } from 'react';

function Dashboard() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <UserProfile />
      </Suspense>
      <Suspense fallback={<div>Loading...</div>}>
        <RecentActivity />
      </Suspense>
    </div>
  );
}
```

## Best Practices

1. **Keep Server Components default** - Only use 'use client' when needed
2. **Keep Client Components small** - Minimize client-side JavaScript
3. **Fetch at the level you need** - Don't over-fetch data
4. **Use Suspense boundaries** - Wrap independent data fetches
5. **Pass serializable props** - Server Components can't pass functions

React Server Components represent a significant shift in how we think about React applications, enabling better performance and developer experience.

