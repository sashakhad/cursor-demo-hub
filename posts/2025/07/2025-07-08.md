---
title: "Understanding Asynchronous JavaScript"
date: "2025.07.08"
tags: [javascript, async, promises, async-await, web-development]
---

Asynchronous programming is fundamental to modern JavaScript. Understanding how to work with asynchronous code is essential for building responsive applications.

## The Problem with Synchronous Code

JavaScript runs code sequentially by default:

```javascript
console.log('Start');
const data = fetchData(); // Blocks execution
console.log('Done');
```

If `fetchData()` takes 2 seconds, nothing else can run during that time.

## Callbacks

The original way to handle async operations:

```javascript
function fetchData(callback) {
  setTimeout(() => {
    callback({ id: 1, name: 'John' });
  }, 1000);
}

fetchData((data) => {
  console.log(data);
});
```

### Callback Hell

Nested callbacks become hard to read:

```javascript
getUser(userId, (user) => {
  getPosts(user.id, (posts) => {
    getComments(posts[0].id, (comments) => {
      console.log(comments);
    });
  });
});
```

## Promises

Promises provide a cleaner async API:

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve({ id: 1, name: 'John' });
  }, 1000);
});

promise.then((data) => {
  console.log(data);
}).catch((error) => {
  console.error(error);
});
```

### Chaining Promises

```javascript
fetch('/api/user')
  .then(response => response.json())
  .then(user => {
    return fetch(`/api/posts/${user.id}`);
  })
  .then(response => response.json())
  .then(posts => {
    console.log(posts);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```

### Promise Methods

```javascript
// Promise.all - wait for all
Promise.all([
  fetch('/api/users'),
  fetch('/api/posts'),
  fetch('/api/comments')
]).then(([users, posts, comments]) => {
  console.log('All data loaded');
});

// Promise.allSettled - wait for all (success or failure)
Promise.allSettled([
  fetch('/api/users'),
  fetch('/api/posts'),
  fetch('/api/comments')
]).then((results) => {
  results.forEach((result) => {
    if (result.status === 'fulfilled') {
      console.log('Success:', result.value);
    } else {
      console.log('Failed:', result.reason);
    }
  });
});

// Promise.race - first to complete
Promise.race([
  fetch('/api/fast'),
  fetch('/api/slow')
]).then(data => {
  console.log('Fastest response:', data);
});
```

## Async/Await

Syntax sugar for Promises:

```javascript
async function fetchUserData() {
  try {
    const user = await fetch('/api/user').then(r => r.json());
    const posts = await fetch(`/api/posts/${user.id}`).then(r => r.json());
    const comments = await fetch(`/api/comments/${posts[0].id}`).then(r => r.json());
    
    return { user, posts, comments };
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}
```

### Parallel Execution

```javascript
async function fetchAllData() {
  // Sequential
  const user = await fetch('/api/user').then(r => r.json());
  const posts = await fetch('/api/posts').then(r => r.json());
  
  // Parallel
  const [user, posts] = await Promise.all([
    fetch('/api/user').then(r => r.json()),
    fetch('/api/posts').then(r => r.json())
  ]);
  
  return { user, posts };
}
```

## Error Handling

```javascript
// Promises
fetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network error');
    }
    return response.json();
  })
  .catch(error => {
    console.error('Caught:', error);
  });

// Async/Await
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new Error('Network error');
    }
    return await response.json();
  } catch (error) {
    console.error('Caught:', error);
    throw error; // Re-throw if needed
  }
}
```

## Common Patterns

### Timeout

```javascript
function fetchWithTimeout(url, timeout = 5000) {
  return Promise.race([
    fetch(url),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Timeout')), timeout)
    )
  ]);
}
```

### Retry Logic

```javascript
async function fetchWithRetry(url, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) return response;
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
```

### Sequential Processing

```javascript
async function processItems(items) {
  const results = [];
  for (const item of items) {
    const result = await processItem(item);
    results.push(result);
  }
  return results;
}
```

## Event Loop

Understanding JavaScript's event loop:

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
}, 0);

Promise.resolve().then(() => {
  console.log('3');
});

console.log('4');

// Output: 1, 4, 3, 2
```

**Execution order:**
1. Synchronous code runs first
2. Microtasks (Promises) run next
3. Macrotasks (setTimeout) run last

## Best Practices

1. **Use async/await** for readability
2. **Handle errors** with try/catch
3. **Avoid await in loops** - use Promise.all
4. **Use Promise.allSettled** when you need all results
5. **Set timeouts** for network requests
6. **Avoid nested awaits** - flatten promise chains
7. **Use AbortController** for cancellable requests

Mastering asynchronous JavaScript enables you to build responsive, efficient applications that handle I/O operations gracefully.

