---
title: "Building Maintainable API Routes in Next.js"
date: "2025.02.20"
tags: [nextjs, api, routes, backend, web-development]
---

Next.js API routes provide a powerful way to build backend functionality alongside your frontend. However, without proper structure, they can quickly become messy and hard to maintain. Here's how to build clean, scalable API routes.

## Basic Structure

Start with a consistent file structure:

```
app/
  api/
    users/
      route.ts          # GET, POST /api/users
      [id]/
        route.ts        # GET, PUT, DELETE /api/users/:id
    posts/
      route.ts
      [slug]/
        route.ts
```

## Type-Safe Request Handlers

Create reusable handler types:

```typescript
// lib/api/types.ts
import { NextRequest, NextResponse } from 'next/server';

export type RouteHandler = (
  request: NextRequest,
  context?: { params: Record<string, string> }
) => Promise<NextResponse>;

export interface RouteHandlers {
  GET?: RouteHandler;
  POST?: RouteHandler;
  PUT?: RouteHandler;
  DELETE?: RouteHandler;
  PATCH?: RouteHandler;
}

export function createRouteHandler(handlers: RouteHandlers) {
  return async (
    request: NextRequest,
    context?: { params: Record<string, string> }
  ) => {
    const method = request.method as keyof RouteHandlers;
    const handler = handlers[method];

    if (!handler) {
      return NextResponse.json(
        { error: 'Method not allowed' },
        { status: 405 }
      );
    }

    try {
      return await handler(request, context);
    } catch (error) {
      console.error('API Error:', error);
      return NextResponse.json(
        { error: 'Internal server error' },
        { status: 500 }
      );
    }
  };
}
```

## Utility Functions

Create shared utilities for common operations:

```typescript
// lib/api/utils.ts
import { NextRequest, NextResponse } from 'next/server';
import { ZodError } from 'zod';

export function parseBody<T>(request: NextRequest): Promise<T> {
  return request.json();
}

export function parseQuery<T>(request: NextRequest): T {
  const url = new URL(request.url);
  const params: Record<string, string> = {};
  
  url.searchParams.forEach((value, key) => {
    params[key] = value;
  });
  
  return params as T;
}

export function successResponse<T>(data: T, status = 200) {
  return NextResponse.json({ data }, { status });
}

export function errorResponse(message: string, status = 400) {
  return NextResponse.json({ error: message }, { status });
}

export function handleValidationError(error: ZodError) {
  return NextResponse.json(
    {
      error: 'Validation failed',
      details: error.errors.map(e => ({
        path: e.path.join('.'),
        message: e.message
      }))
    },
    { status: 400 }
  );
}
```

## Implementing CRUD Operations

Create a complete example with users:

```typescript
// app/api/users/route.ts
import { createRouteHandler } from '@/lib/api/types';
import { parseBody, successResponse, errorResponse } from '@/lib/api/utils';
import { z } from 'zod';

// Validation schemas
const createUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  age: z.number().int().positive().optional()
});

const getUsersSchema = z.object({
  page: z.string().regex(/^\d+$/).transform(Number).optional(),
  limit: z.string().regex(/^\d+$/).transform(Number).optional()
});

// In-memory store (replace with actual database)
let users: User[] = [];
let nextId = 1;

// GET /api/users
async function getUsers(request: NextRequest) {
  const query = parseQuery(request);
  const { page = 1, limit = 10 } = getUsersSchema.parse(query);

  const start = (page - 1) * limit;
  const end = start + limit;
  
  return successResponse({
    users: users.slice(start, end),
    pagination: {
      page,
      limit,
      total: users.length,
      totalPages: Math.ceil(users.length / limit)
    }
  });
}

// POST /api/users
async function createUser(request: NextRequest) {
  const body = await parseBody(request);
  const data = createUserSchema.parse(body);

  const user: User = {
    id: nextId++,
    ...data,
    createdAt: new Date().toISOString()
  };

  users.push(user);
  
  return successResponse(user, 201);
}

export const GET = createRouteHandler({ GET: getUsers });
export const POST = createRouteHandler({ POST: createUser });
```

## Individual Resource Routes

Handle operations on specific resources:

```typescript
// app/api/users/[id]/route.ts
import { createRouteHandler } from '@/lib/api/types';
import { parseBody, successResponse, errorResponse } from '@/lib/api/utils';
import { z } from 'zod';

const updateUserSchema = z.object({
  name: z.string().min(1).optional(),
  email: z.string().email().optional(),
  age: z.number().int().positive().optional()
});

// GET /api/users/:id
async function getUser(request: NextRequest, context?: { params: Record<string, string> }) {
  const id = parseInt(context?.params.id || '0');
  const user = users.find(u => u.id === id);

  if (!user) {
    return errorResponse('User not found', 404);
  }

  return successResponse(user);
}

// PUT /api/users/:id
async function updateUser(request: NextRequest, context?: { params: Record<string, string> }) {
  const id = parseInt(context?.params.id || '0');
  const userIndex = users.findIndex(u => u.id === id);

  if (userIndex === -1) {
    return errorResponse('User not found', 404);
  }

  const body = await parseBody(request);
  const updates = updateUserSchema.parse(body);

  users[userIndex] = {
    ...users[userIndex],
    ...updates,
    updatedAt: new Date().toISOString()
  };

  return successResponse(users[userIndex]);
}

// DELETE /api/users/:id
async function deleteUser(request: NextRequest, context?: { params: Record<string, string> }) {
  const id = parseInt(context?.params.id || '0');
  const userIndex = users.findIndex(u => u.id === id);

  if (userIndex === -1) {
    return errorResponse('User not found', 404);
  }

  users.splice(userIndex, 1);
  
  return successResponse({ deleted: true });
}

export const GET = createRouteHandler({ GET: getUser });
export const PUT = createRouteHandler({ PUT: updateUser });
export const DELETE = createRouteHandler({ DELETE: deleteUser });
```

## Middleware Pattern

Add authentication and logging:

```typescript
// lib/api/middleware.ts
import { NextRequest, NextResponse } from 'next/server';

export function withAuth(handler: RouteHandler): RouteHandler {
  return async (request, context) => {
    const token = request.headers.get('authorization');

    if (!token || !isValidToken(token)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    return handler(request, context);
  };
}

export function withLogging(handler: RouteHandler): RouteHandler {
  return async (request, context) => {
    const start = Date.now();
    const method = request.method;
    const url = request.url;

    console.log(`[${method}] ${url} - Started`);

    try {
      const response = await handler(request, context);
      const duration = Date.now() - start;
      
      console.log(`[${method}] ${url} - Completed in ${duration}ms`);
      
      return response;
    } catch (error) {
      const duration = Date.now() - start;
      console.error(`[${method}] ${url} - Failed after ${duration}ms`, error);
      throw error;
    }
  };
}

// Usage
export const GET = withLogging(withAuth(createRouteHandler({ GET: getUsers })));
```

## Database Integration

Example with Prisma:

```typescript
// app/api/posts/route.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function getPosts(request: NextRequest) {
  const query = parseQuery(request);
  const { page = 1, limit = 10, search } = getPostsSchema.parse(query);

  const where = search ? {
    OR: [
      { title: { contains: search } },
      { content: { contains: search } }
    ]
  } : {};

  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: 'desc' }
    }),
    prisma.post.count({ where })
  ]);

  return successResponse({
    posts,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  });
}

async function createPost(request: NextRequest) {
  const body = await parseBody(request);
  const data = createPostSchema.parse(body);

  const post = await prisma.post.create({
    data: {
      ...data,
      authorId: getCurrentUserId(request)
    }
  });

  return successResponse(post, 201);
}
```

## Error Handling

Centralized error handling:

```typescript
// lib/api/errors.ts
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export class NotFoundError extends ApiError {
  constructor(resource: string) {
    super(404, `${resource} not found`);
  }
}

export class ValidationError extends ApiError {
  constructor(message: string, details?: unknown) {
    super(400, message, details);
  }
}

export class UnauthorizedError extends ApiError {
  constructor() {
    super(401, 'Unauthorized');
  }
}

// Usage
async function getUser(request: NextRequest, context?: { params: Record<string, string> }) {
  const id = parseInt(context?.params.id || '0');
  const user = await prisma.user.findUnique({ where: { id } });

  if (!user) {
    throw new NotFoundError('User');
  }

  return successResponse(user);
}
```

## Testing API Routes

Test your routes with simple unit tests:

```typescript
// __tests__/api/users.test.ts
import { POST } from '@/app/api/users/route';
import { NextRequest } from 'next/server';

describe('/api/users', () => {
  it('creates a user successfully', async () => {
    const request = new NextRequest('http://localhost/api/users', {
      method: 'POST',
      body: JSON.stringify({
        name: 'John Doe',
        email: 'john@example.com'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.data.name).toBe('John Doe');
    expect(data.data.email).toBe('john@example.com');
  });

  it('validates email format', async () => {
    const request = new NextRequest('http://localhost/api/users', {
      method: 'POST',
      body: JSON.stringify({
        name: 'John Doe',
        email: 'invalid-email'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBeDefined();
  });
});
```

## Key Principles

1. **Consistent structure** - Use predictable file organization
2. **Type safety** - Leverage TypeScript and Zod for validation
3. **Reusable utilities** - Extract common patterns
4. **Error handling** - Centralize error management
5. **Middleware** - Compose functionality with middleware
6. **Testing** - Write tests for critical paths
7. **Documentation** - Document your API contracts

Following these patterns will make your Next.js API routes more maintainable, testable, and scalable as your application grows.

