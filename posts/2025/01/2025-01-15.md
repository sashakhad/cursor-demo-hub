---
title: "Mastering TypeScript's Advanced Types"
date: "2025.01.15"
tags: [typescript, types, advanced, programming]
---

TypeScript's type system is incredibly powerful, and learning its advanced features can significantly improve your code quality and developer experience. Let's explore some of the most useful advanced type patterns.

## Conditional Types

Conditional types allow you to create types that depend on other types:

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;

type Result = NonNullable<string | null>; // Result is string

// Extracting return types
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function getString(): string {
  return "hello";
}

type StringReturn = ReturnType<typeof getString>; // string
```

## Mapped Types

Transform types by iterating over their properties:

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

interface User {
  name: string;
  age: number;
}

type ReadonlyUser = Readonly<User>;
// Equivalent to:
// {
//   readonly name: string;
//   readonly age: number;
// }

// Make all properties optional
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// Pick specific properties
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type UserName = Pick<User, 'name'>; // { name: string }
```

## Template Literal Types

Create types from string templates:

```typescript
type EventName<T extends string> = `on${Capitalize<T>}`;

type ClickEvent = EventName<'click'>; // 'onClick'
type ChangeEvent = EventName<'change'>; // 'onChange'

// Combine with unions
type WindowEvents = 'click' | 'focus' | 'blur';
type WindowEventHandlers = {
  [K in WindowEvents as `on${Capitalize<K>}`]: () => void;
};
// Result: { onClick: () => void; onFocus: () => void; onBlur: () => void; }
```

## Utility Types in Action

Practical applications of built-in utility types:

```typescript
// Partial for optional updates
interface UpdateUserRequest {
  name?: string;
  email?: string;
  age?: number;
}

type UpdateUserDto = Partial<User>; // Automatically optional!

// Omit to exclude properties
type UserWithoutPassword = Omit<User, 'password'>;

// Record for dictionary types
type UserRoles = Record<User['id'], 'admin' | 'user' | 'guest'>;

// Extract to filter union types
type EventTypes = 'click' | 'focus' | 'keydown' | 'mousemove';
type MouseEvents = Extract<EventTypes, `${string}mouse${string}` | 'click'>;
// Result: 'click' | 'mousemove'
```

## Branded Types

Add type safety to primitives:

```typescript
type UserId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

function createUserId(id: string): UserId {
  return id as UserId;
}

function createEmail(email: string): Email {
  return email as Email;
}

function sendEmail(userId: UserId, email: Email) {
  // Implementation
}

// This won't compile - extra type safety!
const id = createUserId('123');
const email = createEmail('user@example.com');
sendEmail(email, id); // Error!
```

## Recursive Types

Define recursive data structures:

```typescript
type JsonValue = 
  | string 
  | number 
  | boolean 
  | null 
  | JsonObject 
  | JsonArray;

interface JsonObject {
  [key: string]: JsonValue;
}

interface JsonArray extends Array<JsonValue> {}

type Tree<T> = {
  value: T;
  children: Tree<T>[];
};

const fileTree: Tree<string> = {
  value: 'root',
  children: [
    { value: 'folder1', children: [] },
    { value: 'folder2', children: [
      { value: 'file.txt', children: [] }
    ]}
  ]
};
```

## Advanced Generics

Complex generic patterns:

```typescript
// Constraining generics
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: 'John', age: 30 };
const name = getProperty(user, 'name'); // string
const age = getProperty(user, 'age'); // number

// Multiple type parameters
function zip<T, U>(arr1: T[], arr2: U[]): [T, U][] {
  return arr1.map((item, index) => [item, arr2[index]]);
}

const zipped = zip([1, 2, 3], ['a', 'b', 'c']);
// Result: [[1, 'a'], [2, 'b'], [3, 'c']]

// Higher-order type functions
type Promisify<T> = T extends (...args: infer A) => infer R
  ? (...args: A) => Promise<R>
  : never;

function syncFunction(x: number): string {
  return x.toString();
}

type AsyncFunction = Promisify<typeof syncFunction>;
// Equivalent to: (x: number) => Promise<string>
```

## Type Guards and Assertions

Narrow types safely:

```typescript
// Type guard function
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    // TypeScript knows value is string here
    console.log(value.toUpperCase());
  }
}

// Assertion functions
function assertIsNumber(value: unknown): asserts value is number {
  if (typeof value !== 'number') {
    throw new Error('Expected number');
  }
}

function multiply(value: unknown, factor: number) {
  assertIsNumber(value);
  return value * factor; // value is definitely number here
}
```

## Real-World Example

Let's build a type-safe API client:

```typescript
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

type ApiEndpoint = {
  [path: string]: {
    [method in HttpMethod]?: {
      params?: Record<string, unknown>;
      body?: unknown;
      response: unknown;
    };
  };
};

type Endpoints = {
  '/users': {
    GET: { response: User[] };
    POST: { body: Omit<User, 'id'>; response: User };
  };
  '/users/:id': {
    GET: { params: { id: string }; response: User };
    PUT: { params: { id: string }; body: Partial<User>; response: User };
    DELETE: { params: { id: string }; response: void };
  };
};

function apiRequest<
  Path extends keyof Endpoints,
  Method extends keyof Endpoints[Path]
>(
  path: Path,
  method: Method,
  options?: {
    params?: Endpoints[Path][Method] extends { params: infer P } ? P : never;
    body?: Endpoints[Path][Method] extends { body: infer B } ? B : never;
  }
): Promise<Endpoints[Path][Method] extends { response: infer R } ? R : never> {
  // Implementation
  return fetch(path, { method, body: options?.body }).then(r => r.json());
}

// Usage - fully type-safe!
const users = await apiRequest('/users', 'GET');
const newUser = await apiRequest('/users', 'POST', {
  body: { name: 'John', email: 'john@example.com' }
});
```

## Key Takeaways

1. **Conditional types** enable dynamic type transformations
2. **Mapped types** iterate over properties of existing types
3. **Template literals** create string-based type unions
4. **Utility types** provide common transformations out of the box
5. **Branded types** add extra safety to primitives
6. **Type guards** narrow types in runtime checks
7. **Advanced generics** enable powerful abstractions

Mastering these advanced type features will make your TypeScript code more robust, maintainable, and delightful to work with. Start incorporating them gradually into your projects!

